/*1.	Да се напише функција која како аргументи добива низа од цели броеви и должина на низата.
Функцијата треба да ја измине низата и да ги отфрли оние елементи од низата чија што вредност е
поголема од сумата на елементите пред него (лево во низата). Доколку некој елемент се отфрла
од низата, тогаш неговата вредност не се додава на сумата за проверка на следните елементи во
низата. Постоечката низа, на крајот од извршувањето на функцијата треба да биде променета. Да
се напише главна програма за тестирање на работењето на функцијата.
Пример:
int niza={7,2,15,0,3,13,5};
по извршување: {7,2,0,3,5}
БОНУС: да се напише рекурзивна функција која што како аргументи добива низа од цели броеви и
должина на низата. Функцијата треба да ја измине низата и да не ги отпечати на екран оние
елементи од низата чија што вредност е поголема од сумата на елементите пред него (лево во
низата). Доколку некој елемент не се печати од низата, тогаш неговата вредност не се додава на
сумата за проверка на следните елементи во низата.

*/
#include <stdio.h>
/*bonus:
int suma = 0; // глобална променлива, автоматски е иницијализирана на 0, пошо ако ја ставиме во рек функција 
цело време ќе се иницијализира на 0, а ние сакаме да ја користиме за сумирање на елементите

void funkcija(int *niza, int n) {
    if (n == 0) return;

    if (niza[0] <= suma || suma == 0) {
        printf("%d ", niza[0]);
        suma += niza[0];
    }

    pecati_filtrirani(niza + 1, n - 1);
}*/
int funkcija(int *niza, int *n) {
    int i, j = 0, suma = 0;
    
    for (i = 0; i < *n; i++) {
        if (niza[i] <= suma) {
            niza[j++] = niza[i];  // Задржи го елементот
            suma += niza[i];     // Додај го во сумата
        } else if (i == 0) {
            niza[j++] = niza[i];  // Првиот елемент секогаш останува
            suma += niza[i];
        }
        // ако елементот е поголем → не правиме ништо (значи се фрла)
    }

    *n = j; // Новата големина
    return j; // Колку елементи останале
}

int main() {
    int niza[100] = {7, 2, 15, 0, 3, 13, 5};
    int n = 7, i;

    funkcija(niza, &n);

    printf("Nizata po filtriranje:\n");
    for (i = 0; i < n; i++) {
        printf("%d ", niza[i]);
    }

    return 0;
}

/*2.Да се напише функција која како аргументи добива две низи од цели броеви и должините на
низите. Функцијата треба паралелно да ги изминува двете низи, притоа од првата низа да ги
отфрла оние елементи кои што ги има и во втората низа на иста позиција. Функцијата по
извршувањето треба да ја има променето првата низа. Доколку низите не се со иста должина,
тогаш се изминуваат до должината на помалата низа. Да се напише главна програма за тестирање
на работењето на функцијата и да ја испечати првата низа после повикот на функцијата.
Пример:
int niza1={7,2,15,0,3,4,5};
int niza2={6,1,15,1,13,4,6}
по извршување niza1: {7,2,0,3,5}
БОНУС: да се напише рекурзивна функција која што како аргументи добива две низи од цели
броеви и должините на низите. Функцијата треба паралелно да ги изминува двете низи, притоа од
првата низа да не ги печати оние елементи кои што ги има и во втората низа на иста позиција.
Доколку низите не се со иста должина, тогаш се изминуваат до должината на помалата низа.
*/
#include <stdio.h>
void brisi(int *niza1, int *niza2, int *n1, int *n2) {
    int i, j = 0;
    int min = (*n1 < *n2) ? *n1 : *n2; // помала должина

    for (i = 0; i < min; i++) {
        if (niza1[i] != niza2[i]) {
            niza1[j++] = niza1[i]; // копирај ако не се исти
        }
    }

    *n1 = j; // ажурирана должина на првата низа
}

/*BONUS:
void brisi (int *niza1, int *niza2, int *n1, int *n2){
if (*n1 == 0 || *n2 == 0) return; // Базен случај, ако некоја низа е празна

    if (niza1[0] != niza2[0]) {
        printf("%d ", niza1[0]); // Печати го првиот елемент ако не е ист со вториот
    }

    // Рекурзивно повикување за остатокот од низите
    brisi(niza1 + 1, niza2 + 1, n1 - 1, n2 - 1);
}*/
int main() {
    int niza1[100] = {7, 2, 15, 0, 3, 4, 5};
    int niza2[100] = {6, 1, 15, 1, 13, 4, 6};
    int n1 = 7, n2 = 7; // Должини на низите

    brisi(niza1, niza2, &n1, &n2);

    printf("Niza1 po filtriranje:\n");
    for (int i = 0; i < n1; i++) {
        printf("%d ", niza1[i]);
    }
    printf("\n");

    return 0;
}

/*3. Да се напише функција која како аргументи добива низа од цели броеви и должина на низата.
Функцијата треба да ја измине низата и да ги собира елементите (по апсолутна вредност) од
низата. Доколку наиде на негативен елемент, тој елемент и елементот десно од него (доколку го
има) ги отфрла од низата, но негативниот елемент по апсолутна вредност се додава на сумата.
Постоечката низа, на крајот од извршувањето на функцијата треба да биде променета. На крај да
се отпечати и сумата. Да се напише главна програма за тестирање на работењето на функцијата.
Пример:
int niza={7,2,15,0,-3,13,-5};
по извршување: {7,2,15,0}; sumata e 32 (7+2+15+3+5)
БОНУС: да се напише рекурзивна функција која што како аргументи добива низа од цели броеви и
должина на низата. Функцијата треба да ја измине низата и да ги собира елементите (по
апсолутна вредност) од низата. Исто така, при изминување на елементите, истите ги печати на
екран. Доколку наиде на негативен елемент, тој елемент и елементот десно од него (во низата) не
ги печати на екран, но негативниот елемент по апсолутна вредност се додава на сумата.
*/
#include <stdio.h>
int funk(int *niza, int *n){
    int i, j=0, suma=0;
    for (i=0; i<*n; i++){
        if (niza[i]<0){
            suma+=-niza[i]; // Додај го негативниот елемент по апсолутна вредност
            if (i+1 < *n) {
                // Ако има елемент десно од негативниот, го отфрламе
                niza[i+1] = niza[*n - 1]; // Замени го со последниот елемент
                (*n)--; // Намали ја големината на низата
            }

        }
        else {
            niza[j++] = niza[i]; // Задржи го елементот
            suma += niza[i]; // Додај го во сумата
        }

    }
    *n = j; // Новата големина на низата
    return suma; // Врати ја сумата
}
/*BONUS:
int funk (int *niza, int n) {
    if (n == 0) return 0; // Базен случај

    int suma = 0;
    if (niza[0] < 0) {
        suma += -niza[0]; // Додај негативниот елемент по апсолутна вредност
        if (n > 1) {
            // Ако има елемент десно од негативниот, го отфрламе
            return funk(niza + 2, n - 2); // Прескокни го следниот елемент
        }
        return funk(niza + 1, n - 1); // Продолжи со остатокот од низата
    } else {
        printf("%d ", niza[0]); // Печати го позитивниот елемент
        suma += niza[0]; // Додај го во сумата
        return suma + funk(niza + 1, n - 1); // Продолжи со остатокот од низата
    }
}*/

int main() {
    int niza[100] = {7, 2, 15, 0, -3, 13, -5};
    int n = 7; // Должина на низата
    int suma;

    suma = funk(niza, &n);

    printf("Nizata po filtriranje:\n");
    for (int i = 0; i < n; i++) {
        printf("%d ", niza[i]);
    }
    printf("\nSumata e: %d\n", suma);

    return 0;
}
/*4.	Да се напише функција која како аргументи добива низа од цели броеви и должина на низата.
Функцијата треба да ја измине низата и да ги собира елементите (по апсолутна вредност) од
низата. Доколку наиде на два исти елементи еден по друг, тогаш двата елементи ги отстранува од
низата, а на сумата ја додава половина од вредноста на еден од елементите. Постоечката низа, на
крајот од извршувањето на функцијата треба да биде променета. На крај да се отпечати и сумата.
Да се напише главна програма за тестирање на работењето на функцијата.
Пример:
int niza={7,2,2,0,-3,-3,-5};
по извршување: {7,0,-5}; sumata e 14.0
БОНУС: да се напише рекурзивна функција која што како аргументи добива низа од цели броеви и
должина на низата. Функцијата треба да ја измине низата и да ги собира елементите (по
апсолутна вредност) од низата. Во изминувањето на низата, елементите исто така ги печати на
екран. Доколку наиде на два исти елементи еден по друг, тогаш двата елементи не ги печати на
екран, но на сумата ја додава половина од вредноста на еден од елементите.
*/
#include <stdio.h>

// Глобална променлива за сума (се користи кај двете функции)
float suma = 0;

// Функција за апсолутна вредност 
int aps(int x) {
    return (x < 0) ? -x : x;
}

// Итеративна функција која ги менува елементите на низата и ја пресметува сумата
void soberi(int *niza, int *n) {
    int i = 0, j = 0;
    suma = 0;

    while (i < *n) {
        if (i < *n - 1 && aps(niza[i]) == aps(niza[i + 1])) {
            // Ако два последователни елементи се исти по апсолутна вредност,
            // ги отфрламе и ја додаваме половина вредност на сумата
            suma += aps(niza[i]) / 2.0;
            i += 2;  // Прескокни ги двата елементи
        } else {
            suma += aps(niza[i]);
            niza[j++] = niza[i++];
        }
    }
    *n = j; // ажурирај ја должината на низата
}

/* Рекурзивна верзија со исто име, за бонус (се користи само за печатење, не ја менува низата)
void soberi(int *niza, int n) {
    if (n == 0)
        return;

    if (n > 1 && aps(niza[0]) == aps(niza[1])) {
        suma += aps(niza[0]) / 2.0;
        soberi(niza + 2, n - 2);
    } else {
        suma += aps(niza[0]);
        printf("%d ", niza[0]);
        soberi(niza + 1, n - 1);
    }
}
*/

int main() {
    int niza[] = {7, 2, 2, 0, -3, -3, -5};
    int n = sizeof(niza) / sizeof(niza[0]);

    // Итеративна функција што ја менува низата
    soberi(niza, &n);

    printf("Низа после филтрирање: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", niza[i]);
    }
    printf("\nСума: %.1f\n", suma);


    return 0;
}
/*5.	Да се напише функција која како аргументи добива низа од цели броеви и должина на низата.
Функцијата треба да провери дали секој елемент од низата Х го има Х-пати во низата. На пример:
елементот 2, треба да го има 2 пати во низата, елементот 5, треба да го има 5 пати во низата. Да се
земе во предвид дека Х појавувања на елементот Х, не мора да се последователни. Низата е
составена само од позитивни броеви поголеми од нула. Доколку низата не е составена од
позитивни броеви поголеми од нула, тогаш функцијата враќа -1. Доколку низата не го исполнува
условот (Х пати појавување на елементот Х, притоа ова треба да важи за секој елемент во низата),
тогаш функцијата враќа 0. Доколку е исполнет условот, функцијата враќа 1.
Пример:
int niza={2, 4, 2, 4, 3, 3, 3, 4, 1, 4}; функцијата враќа 1.
int niza2={2, 4, 2, 4, 3, 3, 3, 4, -6, 4}; функцијата враќа -1
*/
#include <stdio.h>
int funk (int *niza, int n) {
    int i, j, count;
    
    // Проверка дали сите елементи се позитивни броеви поголеми од нула
    for (i = 0; i < n; i++) {
        if (niza[i] <= 0) {
            return -1; // Ако најдеме негативен или нулев елемент, враќаме -1
        }
    }

    // Проверка за условот Х пати појавување на елементот Х
    for (i = 0; i < n; i++) {
        count = 0; // Бројач за појавувања на niza[i]
        
        for (j = 0; j < n; j++) {
            if (niza[j] == niza[i]) {
                count++;
            }
        }
        
        if (count != niza[i]) {
            return 0; // Ако не е исполнет условот, враќаме 0
        }
    }
    
    return 1; // Ако се исполнети сите услови, враќаме 1
}
int main() {
    int niza1[100] = {2, 4, 2, 4, 3, 3, 3, 4, 1, 4};
    int niza2[100] = {2, 4, 2, 4, 3, 3, 3, 4, -6, 4};
    int n1 = 10, n2 = 10;

    int result1 = funk(niza1, n1);
    int result2 = funk(niza2, n2);

    printf("Result for niza1: %d\n", result1); // Очекивано: 1
    printf("Result for niza2: %d\n", result2); // Очекивано: -1

    return 0;
}
/*6.	Да се напише функција која како аргументи добива низа од цели броеви и должина на низата.
Функцијата треба да провери (за секој елемент од низата) дали позитивниот елемент Х го има во
низата како негативен Х т.е. -Х. На пример: елементот 2, дали го има во низата како -2. Оние
елементи кои што во низата ја имаат и нивната негативна вредност, елементот заедно со
негативниот елемент се бришат од низата. Функцијата треба да врати колку такви елементи се
избришани. Доколку елементот е 0, тогаш не се брише.
Пример:
int niza={-2, 4, 2, 4, 2, -4, 3, 4, -1, 4};
по трансформација: int niza={ 4, 2, 3, 4, -1, 4}; функцијата враќа 4
Забелешка: Означените елементи во првата низа се тие кои што ќе останат во низата по
извршување на функцијата
*/
#include <stdio.h>

int brisi(int *niza, int *n) {
    int i, j;
    int br = 0; // Бројач на избришани елементи

    for (i = 0; i < *n; i++) {
        if (niza[i] != 0) { // Ако елементот не е 0
            int x = niza[i];
            int nadjeno = 0;
            // Проверуваме дали постои негативна вредност од x
            for (j = 0; j < *n; j++) {
                if (niza[j] == -x) {
                    nadjeno = 1;
                    break;
                }
            }
            if (nadjeno) {
                // Ако постои парот, го бришеме и позитивниот и негативниот елемент
                int k;
                // Бришење на првиот елемент x
                for (k = i; k < *n - 1; k++) {
                    niza[k] = niza[k + 1];
                }
                (*n)--;
                br++;

                // Сега мора да најдеме и го избришеме -x (негативниот пар)
                // Затоа што елементите се преместени, j можеби не е точен, ќе пребараме повторно
                for (k = 0; k < *n; k++) {
                    if (niza[k] == -x) {
                        for (; k < *n - 1; k++) {
                            niza[k] = niza[k + 1];
                        }
                        (*n)--;
                        br++;
                        break;
                    }
                }

                i--; // Намалуваме i за да не прескокнеме елемент по бришењето
            }
        }
    }

    return br; // Враќаме колку елементи се избришани
}

int main() {
    int niza[] = {-2, 4, 2, 4, 2, -4, 3, 4, -1, 4};
    int n = 10;
    int izbrisani = brisi(niza, &n);

    printf("Broj izbrishani elementi: %d\n", izbrisani);
    printf("Nizata: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", niza[i]);
    }
    printf("\n");

    return 0;
}
/*7.	Да се напише функција која како аргументи добива низа од цели броеви и должина на низата.
Функцијата треба да ја трансформира низата, така што, ќе избрише десно од секој елемент еден
елемент (доколку елементот што се проверува е парен) или два елементи (доколку елементот што
се проверува е непарен). На пример: доколку првиот елемент од низата е 2, тогаш се брише само
еден елемент десно од овој елемент, додека пак, доколку елементот е со вредност 3, тогаш се
бришат следните два елементи десно од елементот 3. Низата е составена само од позитивни
броеви поголеми од нула. Доколку низата не е составена од позитивни броеви поголеми од нула,
тогаш функцијата враќа -1. Инаку, функцијата враќа колку елементи се избришани. Доколку
елементот нема доволно елементи да избрише десно од него, тогаш се брише колку што може.
Пример:
int niza={2, 4, 2, 4, 3, 3, 3, 4, 1, 4}; функцијата враќа 5.
низата по трансформација int niza={2, 2, 3, 4, 4};
int niza2={2, 4, 2, 4, 3, 3, 3, 4, -6, 4}; функцијата враќа -1
*/
#include <stdio.h>

int funk(int *niza, int *n) {
    // Проверка дали сите елементи се позитивни и поголеми од 0
    for (int i = 0; i < *n; i++) {
        if (niza[i] <= 0) {
            return -1;
        }
    }

    int br = 0; // Број на избришани елементи

    int i = 0;
    while (i < *n) {
        int brisi = (niza[i] % 2 == 0) ? 1 : 2;

        // Ако нема доволно елементи десно, брише колку што има
        if (i + brisi >= *n) {
            brisi = (*n - 1) - i;
        }

        // Поместување на елементите налево за да се избришат brisi елементи
        for (int j = i + 1; j + brisi < *n; j++) {
            niza[j] = niza[j + brisi];
        }

        *n = *n - brisi; // Намалување на должината на низата
        br += brisi;     // Зголемување на бројот на избришани

        // Не го зголемуваме i бидејќи по намалувањето, на иста позиција е нов елемент
    }

    return br;
}

int main() {
    int niza[100] = {2, 4, 2, 4, 3, 3, 3, 4, 1, 4};
    int niza2[100] = {2, 4, 2, 4, 3, 3, 3, 4, -6, 4};
    
    int n1 = 10;
    int n2 = 10;

    int br1 = funk(niza, &n1);
    printf("Broj za niza1: %d\n", br1);
    printf("Niza1: ");
    for (int i = 0; i < n1; i++) {
        printf("%d ", niza[i]);
    }
    printf("\n");

    int br2 = funk(niza2, &n2);
    printf("Broj za niza2: %d\n", br2);
    printf("Niza2: ");
    for (int i = 0; i < n2; i++) {
        printf("%d ", niza2[i]);
    }
    printf("\n");

    return 0;
}
/*8.	Да се напише функција која како аргументи добива низа од цели броеви и должина на низата.
Функцијата најпрво да ја најде просечната разлика помеѓу сите соседни елементи во низата.
Просечната разлика се прави така што се бара разликата помеѓу сите соседни елементи и сумата
на овие разлики се дели со вкупниот број на вакви разлики. Потоа, функцијата треба да најде
помеѓу кои два соседни елементи од низата, нивната разлика е најдалеку од просечната разлика.
Овие елементи се печатат на екран, а нивната разлика се враќа како резултат од функцијата.
Пример:
int niza={1, 7, 2, 5, 4, 3, 8, 13, 0}; Просечна разлика=(6+5+3+1+1+5+5+13)/8=4
најдалеку е 13, што е разликата помеѓу 13 и 0 елементите. На екран се печати 13 и 0, функцијата
враќа вредност 13
Забелешка: Разлика помеѓу два соседни елементи се пресметува по апсолутна вредност.
*/
#include <stdio.h>

int apsolutna(int x) {
    return (x < 0) ? -x : x;
}

int funk(int *niza, int *n) {
    if (*n < 2) return 0;

    double suma = 0;
    int brojRazliki = *n - 1;

    for (int i = 0; i < brojRazliki; i++) {
        suma += apsolutna(niza[i+1] - niza[i]);
    }

    double prosek = suma / brojRazliki;

    double maxRazlika = -1;
    int indeks = 0;

    for (int i = 0; i < brojRazliki; i++) {
        int razlika = apsolutna(niza[i+1] - niza[i]);
        double najdaleku = (razlika > prosek) ? (razlika - prosek) : (prosek - razlika);

        if (najdaleku > maxRazlika) {
            maxRazlika = najdaleku;
            indeks = i;
        }
    }

    printf("%d и %d\n", niza[indeks], niza[indeks+1]);

    return apsolutna(niza[indeks+1] - niza[indeks]);
}

int main() {
    int niza[] = {1, 7, 2, 5, 4, 3, 8, 13, 0};
    int n = sizeof(niza) / sizeof(niza[0]);

    int rezultat = funk(niza, &n);

    printf("Најдалеку од просекот е разликата: %d\n", rezultat);

    return 0;
}
/*9.	Да се напише функција која како аргументи ќе добие низа од цели броеви 
и должина на низата. Функцијата треба да ги избрише од низата оние елементи кои што 
не се во опсегот од вредноста на првиот елемент и последнипт елемент од низата 
(доколку првиот елемент е поголем од последниот елемент од низата, тогаш опсегот
 се гледа од последнипт елемент до првиот). Оваа проверка не се прави за првиот и
  последнипт елемент. Функцијата треба да врати колку елементи биле отфрлени. 
  Бришењето на елементите од низата да се прави со посебна функција. 
Пример: 
int niza[9]={1,7,0,2,5,0,2,0,4} враќа: 2 
пп трансформација: niza[7]={1,0,2,0,2,0,4}
*/
#include <stdio.h>
void izbishiElement(int *niza, int *n, int pozicija) {
    for (int j = pozicija; j < *n - 1; j++) {
        niza[j] = niza[j + 1];
    }
    (*n)--;
}

int brisi(int *niza, int *n){
    int count = 0;
    int min= niza[0];
    int max= niza[*n-1];
    if (min > max) {
        int temp = min;
        min = max;
        max = temp;
    }
    for (int i = 1; i < *n - 1; i++) {
        if ((niza[i] < min || niza[i] > max) && niza[i] != 0) {
            // Ако елементот не е во опсегот и не е 0, го бришиме}
            count++;
            izbishiElement(niza, n, i);
            i--; // Да не се прескокне елемент
        }
    }
    return count;
}

int main(){
    int niza[9] = {1, 7, 0, 2, 5, 0, 2, 0, 4};
    int n = 9;

    int br = brisi(niza, &n);

    printf("Broj:"" %d\n", br);
    printf("Niza: " );
    for (int i = 0; i < n; i++) {
        printf("%d ", niza[i]);
    }
    printf("\n");

    return 0;
}
/*11.	Треба да се напише функција кпја какп аргумент ќе дпбие низа пд цели брпеви 
и дплжина на низата. Функцијата треба, да креира две нпви низи, така штп, 
вп првата нпва низа ќе ги смести сите елементи пд пригиналната низа штп немаат дупликати,
 дпдека пак, вп втпрата низа ќе ги смести пние елементи кпи штп имаат дупликати 
 (нп ќе ги смести самп еднаш). Функцијата треба да ги птпечати пвие две низи и 
 какп резултат да врати 1, дпкплку низата без дупликати има ппвеќе елементи пд низата сп дупликати, 
 инаку враќа 0. 
Пример: 
int niza[9]={1,7,0,2,5,0,2,0,4}враќа: 1 
пп трансфпрмација: duplikati[2]={0,2} ; neduplikati[4]={1,7,5,4}
*/
#include <stdio.h>

int brojac(int *niza, int n, int broj) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (niza[i] == broj)
            count++;
    }
    return count;
}

int postoi(int *niza, int n, int broj) {
    for (int i = 0; i < n; i++) {
        if (niza[i] == broj)
            return 1;
    }
    return 0;
}

int obrabotka(int *niza, int n) {
    int duplikati[100];
    int neduplikati[100];
    int d = 0, nd = 0;

    for (int i = 0; i < n; i++) {
        int broj = niza[i];
        int kolku = brojac(niza, n, broj);

        if (kolku > 1) {
            // Ако се појавува повеќе од еднаш, и уште не е ставен во duplikati[]
            if (!postoi(duplikati, d, broj)) {
                duplikati[d++] = broj;
            }
        } else {
            // Се појавува само еднаш
            neduplikati[nd++] = broj;
        }
    }

    // Печатење:
    printf("duplikati[%d] = {", d);
    for (int i = 0; i < d; i++) {
        printf("%d", duplikati[i]);
        if (i != d - 1) printf(", ");
    }
    printf("}\n");

    printf("neduplikati[%d] = {", nd);
    for (int i = 0; i < nd; i++) {
        printf("%d", neduplikati[i]);
        if (i != nd - 1) printf(", ");
    }
    printf("}\n");

    return (nd > d) ? 1 : 0;
}

int main() {
    int niza[9] = {1, 7, 0, 2, 5, 0, 2, 0, 4};
    int rezultat = obrabotka(niza, 9);
    printf("Vrakanje: %d\n", rezultat);
    return 0;
}
/*12.	Треба да се напише функција кпја какп аргумент ќе дпбие низа пд цели брпеви
 и дплжина на низата. Функцијата треба, да креира две нпви низи, така штп, 
 вп првата нпва низа ќе ги смести сите елементи пд пригиналната низа штп немаат 
 дупликати а се негативни, дпдека пак, вп втпрата низа ќе ги смести пние елементи
  кпи штп истп така немаат дупликати, нп се ппзитивни или 0. Функцијата треба да ги 
  птпечати пвие две низи и какп резултат да врати 1, дпкплку низата без дупликати сп 
  ппзитивни елементи има ппвеќе елементи пд низата без дупликати сп негативни елементи, 
  инаку враќа 0. 
Пример: 
int niza[9]={1,-7,0,-2,5,0,2,0,4} враќа: 1 
пп трансфпрмација: niza1[1]={-7} ; niza2[3]={1,5,4}
*/
#include <stdio.h>
#include <stdbool.h>

bool negativni(int x) {
    return x < 0;
}

bool pozitivni(int x) {
    return x > 0 || x == 0;
}

int postoi(int *niza, int n, int broj) {
    for (int i = 0; i < n; i++) {
        if (niza[i] == broj)
            return 1;
    }
    return 0;
}

int broj_pojavuvanja(int *niza, int n, int broj) {
    int brojac = 0;
    for (int i = 0; i < n; i++) {
        if (niza[i] == broj)
            brojac++;
    }
    return brojac;
}

int funk(int *niza, int n) {
    int niza1[n], niza2[n];
    int d1 = 0, d2 = 0;

    for (int i = 0; i < n; i++) {
        int broj = niza[i];

        // Само ако бројот не е веќе внесен и се појавува точно еднаш
        if (broj_pojavuvanja(niza, n, broj) == 1) {
            if (negativni(broj)) {
                niza1[d1++] = broj;
            } else if (pozitivni(broj)) {
                niza2[d2++] = broj;
            }
        }
    }

    // Печатење на двете низи
    printf("niza1[%d] = {", d1);
    for (int i = 0; i < d1; i++) {
        printf("%d", niza1[i]);
        if (i < d1 - 1) printf(", ");
    }
    printf("}\n");

    printf("niza2[%d] = {", d2);
    for (int i = 0; i < d2; i++) {
        printf("%d", niza2[i]);
        if (i < d2 - 1) printf(", ");
    }
    printf("}\n");

    return (d2 > d1) ? 1 : 0;
}

int main() {
    int niza[9] = {1, -7, 0, -2, 5, 0, 2, 0, 4};
    int rezultat = funk(niza, 9);
    printf("Vrakanje: %d\n", rezultat);
    return 0;
}

/*13.	Да се напише рекурзивна функција која како аргумент добива низа од целобројни елементи, 
колку елементи има низата и цел број К. Функцијата треба да ги собира елементите на низата се 
додека не се најде вредноста К (или не се измине целата низа). Доколку го најде елементот К,
 не го додава во сумата. Крајната сума од елементите се враќа како резултат од функцијата. 
 Да се напише главна програма за тестирање на работењето на функцијата. 
Пример: 
int niza1={7,2,15,0,3,2,5}; 
повик: rek(niza1,7,3) 
Враќа: 24 (7+2+15+0)
*/
#include <stdio.h>

// Рекурзивна функција за сумирање до појавата на K
int rek(int *niza, int n, int k) {
    if (n == 0) return 0; // базен случај: нема повеќе елементи
    if (niza[0] == k) return 0; // најден елементот K → престанува со собирање
    return niza[0] + rek(niza + 1, n - 1, k); // собира и продолжува
}

int main() {
    int niza1[] = {7, 2, 15, 0, 3, 2, 5};
    int k = 3;
    int n = 7; // должина на низата
    int rezultat = rek(niza1, n, k);
    printf("Suma do %d: %d\n", k, rezultat); // очекувано: 7+2+15+0 = 24
    return 0;
}
